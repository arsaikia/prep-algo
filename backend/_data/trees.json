[
    {
        "_id": "f0ab6fc7-8026-4878-83d6-5dbcb6cd42d2",
        "name": "Invert Binary Tree",
        "link": "invert-binary-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree, invert the tree, and return its root.</p>\n\n  <p>To invert a binary tree, you need to swap every left node with its corresponding right node.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [4,2,7,1,3,6,9]\n<strong>Output:</strong> [4,7,2,9,6,3,1]\n<strong>Explanation:</strong> The tree is inverted by swapping left and right children.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> [2,3,1]\n<strong>Explanation:</strong> Simple tree with just root and two children.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Empty tree returns empty tree.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 100]</li>\n    <li>-100 ≤ Node.val ≤ 100</li>\n  </ul>\n\n  <p><strong>Follow up:</strong> This problem was inspired by this original tweet by Max Howell:</p>\n  <p><em>Google: 90% of our engineers use the software you wrote (Homebrew), but you can't invert a binary tree on a whiteboard so fuck off.</em></p>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 1,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode}\n */\nvar invertTree = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[4,2,7,1,3,6,9]"
                ],
                "expectedOutput": "[4,7,2,9,6,3,1]",
                "explanation": "The tree is inverted by swapping left and right children."
            },
            {
                "inputs": [
                    "[2,1,3]"
                ],
                "expectedOutput": "[2,3,1]",
                "explanation": "Simple tree with just root and two children."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[4,2,7,1,3,6,9]"
                ],
                "expectedOutput": "[4,7,2,9,6,3,1]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[2,1,3]"
                ],
                "expectedOutput": "[2,3,1]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "[1]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2]"
                ],
                "expectedOutput": "[1,null,2]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "[1,3,2,7,6,5,4]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "b51fb3d0-0707-47ce-a51e-66a4b83de16c",
        "name": "Maximum Depth of Binary Tree",
        "link": "maximum-depth-of-binary-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree, return its maximum depth.</p>\n\n  <p>A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The maximum depth is 3: root (1) → 20 (2) → 15 or 7 (3)</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,null,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The maximum depth is 2: root (1) → 2 (2)</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 10^4]</li>\n    <li>-100 ≤ Node.val ≤ 100</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 2,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,9,20,null,null,15,7]"
                ],
                "expectedOutput": "3",
                "explanation": "The maximum depth is 3: root (1) → 20 (2) → 15 or 7 (3)"
            },
            {
                "inputs": [
                    "[1,null,2]"
                ],
                "expectedOutput": "2",
                "explanation": "The maximum depth is 2: root (1) → 2 (2)"
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,9,20,null,null,15,7]"
                ],
                "expectedOutput": "3",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,null,2]"
                ],
                "expectedOutput": "2",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "0",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "1",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "3",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
                ],
                "expectedOutput": "4",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "f525194b-329a-4857-8b63-704826cefd90",
        "name": "Diameter of Binary Tree",
        "link": "diameter-of-binary-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree, return the length of the diameter of the tree.</p>\n\n  <p>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>\n\n  <p>The length of path between two nodes is represented by the number of edges between them.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3,4,5]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> 3 is the length of the path [4,2,1,3] or [5,2,1,3].</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The diameter is the length of the path [2,1] or [1,2].</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 10^4]</li>\n    <li>-100 ≤ Node.val ≤ 100</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 3,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar diameterOfBinaryTree = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3,4,5]"
                ],
                "expectedOutput": "3",
                "explanation": "3 is the length of the path [4,2,1,3] or [5,2,1,3]."
            },
            {
                "inputs": [
                    "[1,2]"
                ],
                "expectedOutput": "1",
                "explanation": "The diameter is the length of the path [2,1] or [1,2]."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3,4,5]"
                ],
                "expectedOutput": "3",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2]"
                ],
                "expectedOutput": "1",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "0",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3]"
                ],
                "expectedOutput": "2",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "4",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
                ],
                "expectedOutput": "6",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "75c1a43b-0dea-4e89-b86c-8826b6539293",
        "name": "Balanced Binary Tree",
        "link": "balanced-binary-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given a binary tree, determine if it is height-balanced.</p>\n\n  <p>For this problem, a height-balanced binary tree is defined as:</p>\n  <p><em>A binary tree in which the left and right subtrees of every node differ in height by no more than 1.</em></p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The left subtree has height 1, right subtree has height 2. Difference is 1, so balanced.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,2,3,3,null,null,4,4]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The left subtree has height 3, right subtree has height 1. Difference is 2, so not balanced.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 5000]</li>\n    <li>-10^4 ≤ Node.val ≤ 10^4</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 4,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isBalanced = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,9,20,null,null,15,7]"
                ],
                "expectedOutput": "true",
                "explanation": "The left subtree has height 1, right subtree has height 2. Difference is 1, so balanced."
            },
            {
                "inputs": [
                    "[1,2,2,3,3,null,null,4,4]"
                ],
                "expectedOutput": "false",
                "explanation": "The left subtree has height 3, right subtree has height 1. Difference is 2, so not balanced."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,9,20,null,null,15,7]"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,2,3,3,null,null,4,4]"
                ],
                "expectedOutput": "false",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "BOOLEAN"
        }
    },
    {
        "_id": "c095b9f7-db6d-4785-aee4-263def8b7db0",
        "name": "Same Tree",
        "link": "same-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the roots of two binary trees p and q, write a function to check if they are the same or not.</p>\n\n  <p>Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> p = [1,2,3], q = [1,2,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Both trees have the same structure and values.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> p = [1,2], q = [1,null,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The trees have different structures.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> p = [1,2,1], q = [1,1,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The trees have the same structure but different values.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in both trees is in the range [0, 100]</li>\n    <li>-10^4 ≤ Node.val ≤ 10^4</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 5,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3]",
                    "[1,2,3]"
                ],
                "expectedOutput": "true",
                "explanation": "Both trees have the same structure and values."
            },
            {
                "inputs": [
                    "[1,2]",
                    "[1,null,2]"
                ],
                "expectedOutput": "false",
                "explanation": "The trees have different structures."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3]",
                    "[1,2,3]"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2]",
                    "[1,null,2]"
                ],
                "expectedOutput": "false",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,1]",
                    "[1,1,2]"
                ],
                "expectedOutput": "false",
                "isHidden": true
            },
            {
                "inputs": [
                    "[]",
                    "[]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1]",
                    "[1]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5]",
                    "[1,2,3,4,5]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "TREE"
            ],
            "output": "BOOLEAN"
        }
    },
    {
        "_id": "8c49d041-290a-471a-a28a-167aab175fe6",
        "name": "Subtree of Another Tree",
        "link": "subtree-of-another-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.</p>\n\n  <p>A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,4,5,1,2], subRoot = [4,1,2]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The subtree rooted at node 4 has the same structure and values as subRoot.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The subtree rooted at node 4 has different values than subRoot.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the root tree is in the range [1, 2000]</li>\n    <li>The number of nodes in the subRoot tree is in the range [1, 1000]</li>\n    <li>-10^4 ≤ root.val ≤ 10^4</li>\n    <li>-10^4 ≤ subRoot.val ≤ 10^4</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 6,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} subRoot\n * @return {boolean}\n */\nvar isSubtree = function(root, subRoot) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,4,5,1,2]",
                    "[4,1,2]"
                ],
                "expectedOutput": "true",
                "explanation": "The subtree rooted at node 4 has the same structure and values as subRoot."
            },
            {
                "inputs": [
                    "[3,4,5,1,2,null,null,null,null,0]",
                    "[4,1,2]"
                ],
                "expectedOutput": "false",
                "explanation": "The subtree rooted at node 4 has different values than subRoot."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,4,5,1,2]",
                    "[4,1,2]"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[3,4,5,1,2,null,null,null,null,0]",
                    "[4,1,2]"
                ],
                "expectedOutput": "false",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,1]",
                    "[1]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3]",
                    "[1,2]"
                ],
                "expectedOutput": "false",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]",
                    "[2,4,5]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]",
                    "[2,4,6]"
                ],
                "expectedOutput": "false",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "TREE"
            ],
            "output": "BOOLEAN"
        }
    },
    {
        "_id": "c9214939-0088-4203-ba55-c0ed02ee6a82",
        "name": "Lowest Common Ancestor of a Binary Search Tree",
        "link": "lowest-common-ancestor-of-a-binary-search-tree/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.</p>\n\n  <p>According to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\"</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The LCA of nodes 2 and 8 is 6.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [2, 10^5]</li>\n    <li>-10^9 ≤ Node.val ≤ 10^9</li>\n    <li>All Node.val are unique</li>\n    <li>p != q</li>\n    <li>p and q will exist in the BST</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 100201000,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[6,2,8,0,4,7,9,null,null,3,5]",
                    "2",
                    "8"
                ],
                "expectedOutput": "6",
                "explanation": "The LCA of nodes 2 and 8 is 6."
            },
            {
                "inputs": [
                    "[6,2,8,0,4,7,9,null,null,3,5]",
                    "2",
                    "4"
                ],
                "expectedOutput": "2",
                "explanation": "The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[6,2,8,0,4,7,9,null,null,3,5]",
                    "2",
                    "8"
                ],
                "expectedOutput": "6",
                "isHidden": false
            },
            {
                "inputs": [
                    "[6,2,8,0,4,7,9,null,null,3,5]",
                    "2",
                    "4"
                ],
                "expectedOutput": "2",
                "isHidden": false
            },
            {
                "inputs": [
                    "[2,1]",
                    "2",
                    "1"
                ],
                "expectedOutput": "2",
                "isHidden": true
            },
            {
                "inputs": [
                    "[6,2,8,0,4,7,9,null,null,3,5]",
                    "0",
                    "5"
                ],
                "expectedOutput": "2",
                "isHidden": true
            },
            {
                "inputs": [
                    "[6,2,8,0,4,7,9,null,null,3,5]",
                    "7",
                    "9"
                ],
                "expectedOutput": "8",
                "isHidden": true
            },
            {
                "inputs": [
                    "[6,2,8,0,4,7,9,null,null,3,5]",
                    "3",
                    "5"
                ],
                "expectedOutput": "4",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER",
                "NUMBER"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "43950da3-f031-4e52-bb87-bfea5533951d",
        "name": "Binary Tree Level Order Traversal",
        "link": "binary-tree-level-order-traversal/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,9,20,null,null,15,7]\n<strong>Output:</strong> [[3],[9,20],[15,7]]\n<strong>Explanation:</strong> Level 0: [3], Level 1: [9,20], Level 2: [15,7]</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1]\n<strong>Output:</strong> [[1]]\n<strong>Explanation:</strong> Single node tree.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Empty tree returns empty list.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 2000]</li>\n    <li>-1000 ≤ Node.val ≤ 1000</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 7,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom typing import List, Optional\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,9,20,null,null,15,7]"
                ],
                "expectedOutput": "[[3],[9,20],[15,7]]",
                "explanation": "Level 0: [3], Level 1: [9,20], Level 2: [15,7]"
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "[[1]]",
                "explanation": "Single node tree."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,9,20,null,null,15,7]"
                ],
                "expectedOutput": "[[3],[9,20],[15,7]]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "[[1]]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "[[1],[2,3],[4,5,6,7]]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
                ],
                "expectedOutput": "[[1],[2,3],[4,5,6,7],[8,9,10,11,12,13,14,15]]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,null,2,null,3]"
                ],
                "expectedOutput": "[[1],[2],[3]]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "2f0741eb-5330-4498-83e5-6fd469129126",
        "name": "Binary Tree Right Side View",
        "link": "binary-tree-right-side-view/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3,null,5,null,4]\n<strong>Output:</strong> [1,3,4]\n<strong>Explanation:</strong> From the right side, you can see nodes 1, 3, and 4.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,null,3]\n<strong>Output:</strong> [1,3]\n<strong>Explanation:</strong> From the right side, you can see nodes 1 and 3.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Empty tree returns empty list.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 100]</li>\n    <li>-100 ≤ Node.val ≤ 100</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 1,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom typing import List, Optional\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar rightSideView = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3,null,5,null,4]"
                ],
                "expectedOutput": "[1,3,4]",
                "explanation": "From the right side, you can see nodes 1, 3, and 4."
            },
            {
                "inputs": [
                    "[1,null,3]"
                ],
                "expectedOutput": "[1,3]",
                "explanation": "From the right side, you can see nodes 1 and 3."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3,null,5,null,4]"
                ],
                "expectedOutput": "[1,3,4]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,null,3]"
                ],
                "expectedOutput": "[1,3]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "[1,3,7]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
                ],
                "expectedOutput": "[1,3,7,15]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]"
                ],
                "expectedOutput": "[1,3,7,15,31]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "ARRAY"
        }
    },
    {
        "_id": "788bc8dd-e1ca-495a-9430-40a5ed8f431e",
        "name": "Count Good Nodes In Binary Tree",
        "link": "count-good-nodes-in-binary-tree/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.</p>\n\n  <p>Return the number of good nodes in the binary tree.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,1,4,3,null,1,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Nodes in blue are good.\nRoot Node (3) is always a good node.\nNode 4 -> (3,4) is the maximum value in the path starting from the root.\nNode 5 -> (3,4,5) is the maximum value in the path.\nNode 3 -> (3,1,3) is the maximum value in the path.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [3,3,null,4,2]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = [1]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Root is considered as good.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the binary tree is in the range [1, 10^5]</li>\n    <li>Each node's value is between [-10^4, 10^4]</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 2,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar goodNodes = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,1,4,3,null,1,5]"
                ],
                "expectedOutput": "4",
                "explanation": "Nodes in blue are good. Root Node (3) is always a good node. Node 4 -> (3,4) is the maximum value in the path starting from the root. Node 5 -> (3,4,5) is the maximum value in the path. Node 3 -> (3,1,3) is the maximum value in the path."
            },
            {
                "inputs": [
                    "[3,3,null,4,2]"
                ],
                "expectedOutput": "3",
                "explanation": "Node 2 -> (3, 3, 2) is not good, because \"3\" is higher than it."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,1,4,3,null,1,5]"
                ],
                "expectedOutput": "4",
                "isHidden": false
            },
            {
                "inputs": [
                    "[3,3,null,4,2]"
                ],
                "expectedOutput": "3",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "1",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "7",
                "isHidden": true
            },
            {
                "inputs": [
                    "[5,1,7,2,3,6,8]"
                ],
                "expectedOutput": "3",
                "isHidden": true
            },
            {
                "inputs": [
                    "[10,5,15,3,7,12,18]"
                ],
                "expectedOutput": "4",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "f48b5c28-fc21-445f-a295-aa92c9a689d5",
        "name": "Validate Binary Search Tree",
        "link": "validate-binary-search-tree/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given the root of a binary tree, determine if it is a valid binary search tree (BST).</p>\n\n  <p>A valid BST is defined as follows:</p>\n  <ul>\n    <li>The left subtree of a node contains only nodes with keys less than the node's key.</li>\n    <li>The right subtree of a node contains only nodes with keys greater than the node's key.</li>\n    <li>Both the left and right subtrees must also be binary search trees.</li>\n  </ul>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [2,1,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The tree satisfies BST properties: left child (1) < root (2) < right child (3).</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [5,1,4,null,null,3,6]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The root node's value is 5 but its right child's value is 4, which violates BST property.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 10^4]</li>\n    <li>-2^31 ≤ Node.val ≤ 2^31 - 1</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 8,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[2,1,3]"
                ],
                "expectedOutput": "true",
                "explanation": "The tree satisfies BST properties: left child (1) < root (2) < right child (3)."
            },
            {
                "inputs": [
                    "[5,1,4,null,null,3,6]"
                ],
                "expectedOutput": "false",
                "explanation": "The root node's value is 5 but its right child's value is 4, which violates BST property."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[2,1,3]"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[5,1,4,null,null,3,6]"
                ],
                "expectedOutput": "false",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,1]"
                ],
                "expectedOutput": "false",
                "isHidden": true
            },
            {
                "inputs": [
                    "[5,1,7,null,null,6,8]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[5,1,7,null,null,6,4]"
                ],
                "expectedOutput": "false",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "BOOLEAN"
        }
    },
    {
        "_id": "ba6b1543-1658-4f1f-924e-985f56e187d2",
        "name": "Construct Binary Tree From Preorder And Inorder Traversal",
        "link": "construct-binary-tree-from-preorder-and-inorder-traversal/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n<strong>Explanation:</strong> The binary tree is constructed from the traversal arrays.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> preorder = [-1], inorder = [-1]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> Single node tree.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>1 ≤ preorder.length ≤ 3000</li>\n    <li>inorder.length == preorder.length</li>\n    <li>-3000 ≤ preorder[i], inorder[i] ≤ 3000</li>\n    <li>preorder and inorder consist of unique values.</li>\n    <li>Each value of inorder also appears in preorder.</li>\n    <li>preorder is guaranteed to be the preorder traversal of the tree.</li>\n    <li>inorder is guaranteed to be the inorder traversal of the tree.</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 100101000,
        "templates": {
            "python": "from typing import List, Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} preorder\n * @param {number[]} inorder\n * @return {TreeNode}\n */\nvar buildTree = function(preorder, inorder) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,9,20,15,7]",
                    "[9,3,15,20,7]"
                ],
                "expectedOutput": "[3,9,20,null,null,15,7]",
                "explanation": "The binary tree is constructed from the traversal arrays."
            },
            {
                "inputs": [
                    "[-1]",
                    "[-1]"
                ],
                "expectedOutput": "[-1]",
                "explanation": "Single node tree."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,9,20,15,7]",
                    "[9,3,15,20,7]"
                ],
                "expectedOutput": "[3,9,20,null,null,15,7]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[-1]",
                    "[-1]"
                ],
                "expectedOutput": "[-1]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,3]",
                    "[2,1,3]"
                ],
                "expectedOutput": "[1,2,3]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,4,5,3,6]",
                    "[4,2,5,1,6,3]"
                ],
                "expectedOutput": "[1,2,3,4,5,6]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "ARRAY",
                "ARRAY"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "923ec71e-93ef-408f-969b-b7abeef2a47f",
        "name": "Binary Tree Maximum Path Sum",
        "link": "binary-tree-maximum-path-sum/",
        "group": "Trees",
        "difficulty": "Hard",
        "description": "<div>\n  <p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p>\n\n  <p>The path sum of a path is the sum of the node's values in the path.</p>\n\n  <p>Given the root of a binary tree, return the maximum path sum of any non-empty path.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [-10,9,20,null,null,15,7]\n<strong>Output:</strong> 42\n<strong>Explanation:</strong> The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 3 * 10^4]</li>\n    <li>-1000 ≤ Node.val ≤ 1000</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 3,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxPathSum = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3]"
                ],
                "expectedOutput": "6",
                "explanation": "The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6."
            },
            {
                "inputs": [
                    "[-10,9,20,null,null,15,7]"
                ],
                "expectedOutput": "42",
                "explanation": "The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3]"
                ],
                "expectedOutput": "6",
                "isHidden": false
            },
            {
                "inputs": [
                    "[-10,9,20,null,null,15,7]"
                ],
                "expectedOutput": "42",
                "isHidden": false
            },
            {
                "inputs": [
                    "[2,-1]"
                ],
                "expectedOutput": "2",
                "isHidden": true
            },
            {
                "inputs": [
                    "[-3]"
                ],
                "expectedOutput": "-3",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,-2,3]"
                ],
                "expectedOutput": "3",
                "isHidden": true
            },
            {
                "inputs": [
                    "[5,4,8,11,null,13,4,7,2,null,null,null,1]"
                ],
                "expectedOutput": "48",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "f7a4f43c-c804-45b2-9a46-40f9e85391ea",
        "name": "Serialize And Deserialize Binary Tree",
        "link": "serialize-and-deserialize-binary-tree/",
        "group": "Trees",
        "difficulty": "Hard",
        "description": "<div>\n  <p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p>\n\n  <p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3,null,null,4,5]\n<strong>Output:</strong> [1,2,3,null,null,4,5]\n<strong>Explanation:</strong> The tree is serialized and then deserialized back to the same structure.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Empty tree is handled correctly.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 10^4]</li>\n    <li>-1000 ≤ Node.val ≤ 1000</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 4,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Codec:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        # Write your solution here\n        pass\n    \n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    // Write your solution here\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3,null,null,4,5]"
                ],
                "expectedOutput": "[1,2,3,null,null,4,5]",
                "explanation": "The tree is serialized and then deserialized back to the same structure."
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "explanation": "Empty tree is handled correctly."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3,null,null,4,5]"
                ],
                "expectedOutput": "[1,2,3,null,null,4,5]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "[1]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "[1,2,3,4,5,6,7]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "c40ed0ba-81a5-4705-b48a-ad5ab8bd97b6",
        "name": "Binary Tree Inorder Traversal",
        "link": "binary-tree-inorder-traversal/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree, return the inorder traversal of its nodes' values.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,3,2]\n<strong>Explanation:</strong> Inorder traversal: left subtree -> root -> right subtree</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Empty tree returns empty list.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> Single node tree.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 100]</li>\n    <li>-100 ≤ Node.val ≤ 100</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 1000000,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nfrom typing import List, Optional\n\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar inorderTraversal = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,null,2,3]"
                ],
                "expectedOutput": "[1,3,2]",
                "explanation": "Inorder traversal: left subtree -> root -> right subtree"
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "explanation": "Empty tree returns empty list."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,null,2,3]"
                ],
                "expectedOutput": "[1,3,2]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "[1]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "[4,2,5,1,6,3,7]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
                ],
                "expectedOutput": "[8,4,9,2,10,5,11,1,12,6,13,3,14,7,15]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,null,2,null,3]"
                ],
                "expectedOutput": "[1,2,3]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "ARRAY"
        }
    },
    {
        "_id": "e9788ebe-ae89-470f-b10f-c53137013715",
        "name": "Binary Tree Preorder Traversal",
        "link": "binary-tree-preorder-traversal/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree, return the preorder traversal of its nodes' values.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [1,2,3]\n<strong>Explanation:</strong> Preorder traversal: root -> left subtree -> right subtree</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Empty tree returns empty list.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> Single node tree.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 100]</li>\n    <li>-100 ≤ Node.val ≤ 100</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 2000000,
        "templates": {
            "python": "from typing import List, Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar preorderTraversal = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,null,2,3]"
                ],
                "expectedOutput": "[1,2,3]",
                "explanation": "Preorder traversal: root -> left subtree -> right subtree"
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "explanation": "Empty tree returns empty list."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,null,2,3]"
                ],
                "expectedOutput": "[1,2,3]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "[1]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "[1,2,4,5,3,6,7]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "ARRAY"
        }
    },
    {
        "_id": "21f78ee6-95ec-4051-8936-00ea6ae4e3cf",
        "name": "Binary Tree Postorder Traversal",
        "link": "binary-tree-postorder-traversal/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree, return the postorder traversal of its nodes' values.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,null,2,3]\n<strong>Output:</strong> [3,2,1]\n<strong>Explanation:</strong> Postorder traversal: left subtree -> right subtree -> root</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = []\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Empty tree returns empty list.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = [1]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> Single node tree.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 100]</li>\n    <li>-100 ≤ Node.val ≤ 100</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 1000000,
        "templates": {
            "python": "from typing import List, Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar postorderTraversal = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,null,2,3]"
                ],
                "expectedOutput": "[3,2,1]",
                "explanation": "Postorder traversal: left subtree -> right subtree -> root"
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "explanation": "Empty tree returns empty list."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,null,2,3]"
                ],
                "expectedOutput": "[3,2,1]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]"
                ],
                "expectedOutput": "[]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "[1]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "[4,5,2,6,7,3,1]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "ARRAY"
        }
    },
    {
        "_id": "9ae1d34b-e9fe-44af-9360-e1c2a428b38d",
        "name": "Search in a BST",
        "link": "search-in-a-binary-search-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>You are given the root of a binary search tree (BST) and an integer val.</p>\n\n  <p>Find the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [4,2,7,1,3], val = 2\n<strong>Output:</strong> [2,1,3]\n<strong>Explanation:</strong> The subtree rooted at node 2 contains nodes 1 and 3.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [4,2,7,1,3], val = 5\n<strong>Output:</strong> []\n<strong>Explanation:</strong> Value 5 is not found in the BST.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 5000]</li>\n    <li>1 ≤ Node.val ≤ 10^7</li>\n    <li>root is a valid binary search tree</li>\n    <li>1 ≤ val ≤ 10^7</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 101000000,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nvar searchBST = function(root, val) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[4,2,7,1,3]",
                    "2"
                ],
                "expectedOutput": "[2,1,3]",
                "explanation": "The subtree rooted at node 2 contains nodes 1 and 3."
            },
            {
                "inputs": [
                    "[4,2,7,1,3]",
                    "5"
                ],
                "expectedOutput": "[]",
                "explanation": "Value 5 is not found in the BST."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[4,2,7,1,3]",
                    "2"
                ],
                "expectedOutput": "[2,1,3]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[4,2,7,1,3]",
                    "5"
                ],
                "expectedOutput": "[]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]",
                    "1"
                ],
                "expectedOutput": "[1]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[5,3,6,2,4,null,7]",
                    "3"
                ],
                "expectedOutput": "[3,2,4]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "7df6d74b-2567-4298-b221-13b4f23f6afd",
        "name": "Insert into a Binary Search Tree",
        "link": "insert-into-a-binary-search-tree/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.</p>\n\n  <p>Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [4,2,7,1,3], val = 5\n<strong>Output:</strong> [4,2,7,1,3,5]\n<strong>Explanation:</strong> Another accepted tree is [5,2,7,1,3,null,null,null,4].</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [40,20,60,10,30,50,70], val = 25\n<strong>Output:</strong> [40,20,60,10,30,50,70,null,null,25]\n<strong>Explanation:</strong> The value 25 is inserted as a leaf node.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree will be in the range [0, 10^4]</li>\n    <li>-10^8 ≤ Node.val ≤ 10^8</li>\n    <li>All the values Node.val are unique</li>\n    <li>-10^8 ≤ val ≤ 10^8</li>\n    <li>It's guaranteed that val does not exist in the original BST</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 101020000,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} val\n * @return {TreeNode}\n */\nvar insertIntoBST = function(root, val) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[4,2,7,1,3]",
                    "5"
                ],
                "expectedOutput": "[4,2,7,1,3,5]",
                "explanation": "The value 5 is inserted into the BST."
            },
            {
                "inputs": [
                    "[40,20,60,10,30,50,70]",
                    "25"
                ],
                "expectedOutput": "[40,20,60,10,30,50,70,null,null,25]",
                "explanation": "The value 25 is inserted as a leaf node."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[4,2,7,1,3]",
                    "5"
                ],
                "expectedOutput": "[4,2,7,1,3,5]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[40,20,60,10,30,50,70]",
                    "25"
                ],
                "expectedOutput": "[40,20,60,10,30,50,70,null,null,25]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[4,2,7,1,3,null,null,null,null,null,null]",
                    "5"
                ],
                "expectedOutput": "[4,2,7,1,3,5]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[]",
                    "5"
                ],
                "expectedOutput": "[5]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "72be3d27-eeb1-4500-9309-b74700a0103d",
        "name": "Delete Node in a BST",
        "link": "delete-node-in-a-bst/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.</p>\n\n  <p>Basically, the deletion can be divided into two stages:</p>\n  <ol>\n    <li>Search for a node to remove.</li>\n    <li>If the node is found, delete the node.</li>\n  </ol>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 3\n<strong>Output:</strong> [5,4,6,2,null,null,7]\n<strong>Explanation:</strong> Given key to delete is 3. So we find the node with value 3 and delete it.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [5,3,6,2,4,null,7], key = 0\n<strong>Output:</strong> [5,3,6,2,4,null,7]\n<strong>Explanation:</strong> The tree does not contain a node with value = 0.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 10^4]</li>\n    <li>-10^5 ≤ Node.val ≤ 10^5</li>\n    <li>Each node has a unique value</li>\n    <li>root is a valid binary search tree</li>\n    <li>-10^5 ≤ key ≤ 10^5</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 101030000,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} key\n * @return {TreeNode}\n */\nvar deleteNode = function(root, key) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[5,3,6,2,4,null,7]",
                    "3"
                ],
                "expectedOutput": "[5,4,6,2,null,null,7]",
                "explanation": "Given key to delete is 3. So we find the node with value 3 and delete it."
            },
            {
                "inputs": [
                    "[5,3,6,2,4,null,7]",
                    "0"
                ],
                "expectedOutput": "[5,3,6,2,4,null,7]",
                "explanation": "The tree does not contain a node with value = 0."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[5,3,6,2,4,null,7]",
                    "3"
                ],
                "expectedOutput": "[5,4,6,2,null,null,7]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[5,3,6,2,4,null,7]",
                    "0"
                ],
                "expectedOutput": "[5,3,6,2,4,null,7]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]",
                    "0"
                ],
                "expectedOutput": "[]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[5,3,6,2,4,null,7]",
                    "5"
                ],
                "expectedOutput": "[6,3,7,2,4]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "d19405ae-1a36-4a0d-b229-a49eecd98021",
        "name": "Kth Smallest Element In a Bst",
        "link": "kth-smallest-element-in-a-bst/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,1,4,null,2], k = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The 1st smallest element is 1.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The 3rd smallest element is 3.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is n</li>\n    <li>1 ≤ k ≤ n ≤ 10^4</li>\n    <li>0 ≤ Node.val ≤ 10^4</li>\n  </ul>\n\n  <p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 101050000,
        "templates": {
            "python": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} k\n * @return {number}\n */\nvar kthSmallest = function(root, k) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,1,4,null,2]",
                    "1"
                ],
                "expectedOutput": "1",
                "explanation": "The 1st smallest element is 1."
            },
            {
                "inputs": [
                    "[5,3,6,2,4,null,null,1]",
                    "3"
                ],
                "expectedOutput": "3",
                "explanation": "The 3rd smallest element is 3."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,1,4,null,2]",
                    "1"
                ],
                "expectedOutput": "1",
                "isHidden": false
            },
            {
                "inputs": [
                    "[5,3,6,2,4,null,null,1]",
                    "3"
                ],
                "expectedOutput": "3",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]",
                    "1"
                ],
                "expectedOutput": "1",
                "isHidden": true
            },
            {
                "inputs": [
                    "[3,1,4,null,2]",
                    "2"
                ],
                "expectedOutput": "2",
                "isHidden": true
            },
            {
                "inputs": [
                    "[5,3,6,2,4,null,null,1]",
                    "5"
                ],
                "expectedOutput": "5",
                "isHidden": true
            },
            {
                "inputs": [
                    "[10,5,15,3,7,12,18]",
                    "4"
                ],
                "expectedOutput": "7",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "e2cdbe6f-2aba-4377-858a-1f3ca6b69352",
        "name": "Construct Binary Tree from Inorder and Postorder Traversal",
        "link": "construct-binary-tree-from-inorder-and-postorder-traversal/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n<strong>Output:</strong> [3,9,20,null,null,15,7]\n<strong>Explanation:</strong> The binary tree is constructed from the traversal arrays.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> inorder = [-1], postorder = [-1]\n<strong>Output:</strong> [-1]\n<strong>Explanation:</strong> Single node tree.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>1 ≤ inorder.length ≤ 3000</li>\n    <li>postorder.length == inorder.length</li>\n    <li>-3000 ≤ inorder[i], postorder[i] ≤ 3000</li>\n    <li>inorder and postorder consist of unique values.</li>\n    <li>Each value of postorder also appears in inorder.</li>\n    <li>inorder is guaranteed to be the inorder traversal of the tree.</li>\n    <li>postorder is guaranteed to be the postorder traversal of the tree.</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 100102000,
        "templates": {
            "python": "from typing import List, Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nvar buildTree = function(inorder, postorder) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[9,3,15,20,7]",
                    "[9,15,7,20,3]"
                ],
                "expectedOutput": "[3,9,20,null,null,15,7]",
                "explanation": "The binary tree is constructed from the traversal arrays."
            },
            {
                "inputs": [
                    "[-1]",
                    "[-1]"
                ],
                "expectedOutput": "[-1]",
                "explanation": "Single node tree."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[9,3,15,20,7]",
                    "[9,15,7,20,3]"
                ],
                "expectedOutput": "[3,9,20,null,null,15,7]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[-1]",
                    "[-1]"
                ],
                "expectedOutput": "[-1]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[2,1,3]",
                    "[2,3,1]"
                ],
                "expectedOutput": "[1,2,3]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[4,2,5,1,6,3,7]",
                    "[4,5,2,6,7,3,1]"
                ],
                "expectedOutput": "[1,2,3,4,5,6,7]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "ARRAY",
                "ARRAY"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "357f70b6-4676-4816-a5bc-770841a97459",
        "name": "Lowest Common Ancestor of a Binary Tree",
        "link": "lowest-common-ancestor-of-a-binary-tree/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p>\n\n  <p>According to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\"</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [2, 10^5]</li>\n    <li>-10^9 ≤ Node.val ≤ 10^9</li>\n    <li>All Node.val are unique</li>\n    <li>p != q</li>\n    <li>p and q will exist in the tree</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 100201000,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: Optional[TreeNode], p: Optional[TreeNode], q: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "1"
                ],
                "expectedOutput": "3",
                "explanation": "The LCA of nodes 5 and 1 is 3."
            },
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "4"
                ],
                "expectedOutput": "5",
                "explanation": "The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "1"
                ],
                "expectedOutput": "3",
                "isHidden": false
            },
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "4"
                ],
                "expectedOutput": "5",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2]",
                    "1",
                    "2"
                ],
                "expectedOutput": "1",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]",
                    "4",
                    "5"
                ],
                "expectedOutput": "2",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER",
                "NUMBER"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "ae317130-c4b5-48fe-8659-7b1cfd0d2943",
        "name": "Convert Sorted Array to Binary Search Tree",
        "link": "convert-sorted-array-to-binary-search-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.</p>\n\n  <p>A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> nums = [-10,-3,0,5,9]\n<strong>Output:</strong> [0,-3,9,-10,null,5]\n<strong>Explanation:</strong> One possible answer is [0,-3,9,-10,null,5], which represents the height-balanced BST.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> nums = [1,3]\n<strong>Output:</strong> [3,1]\n<strong>Explanation:</strong> [1,3] and [3,1] are both height-balanced BSTs.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>1 ≤ nums.length ≤ 10^4</li>\n    <li>-10^4 ≤ nums[i] ≤ 10^4</li>\n    <li>nums is sorted in a strictly increasing order</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 100103000,
        "templates": {
            "python": "from typing import List, Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} nums\n * @return {TreeNode}\n */\nvar sortedArrayToBST = function(nums) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[-10,-3,0,5,9]"
                ],
                "expectedOutput": "[0,-3,9,-10,null,5]",
                "explanation": "One possible answer is [0,-3,9,-10,null,5], which represents the height-balanced BST."
            },
            {
                "inputs": [
                    "[1,3]"
                ],
                "expectedOutput": "[3,1]",
                "explanation": "[1,3] and [3,1] are both height-balanced BSTs."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[-10,-3,0,5,9]"
                ],
                "expectedOutput": "[0,-3,9,-10,null,5]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,3]"
                ],
                "expectedOutput": "[3,1]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,3,4,5]"
                ],
                "expectedOutput": "[3,1,4,null,2,null,5]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "[1]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "ARRAY"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "defc28b7-1e37-48d3-b1f8-a0249dc3f687",
        "name": "Merge Two Binary Trees",
        "link": "merge-two-binary-trees/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>You are given two binary trees root1 and root2.</p>\n\n  <p>Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.</p>\n\n  <p>Return the merged tree.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\n<strong>Output:</strong> [3,4,5,5,4,null,7]\n<strong>Explanation:</strong> The merged tree is created by summing overlapping nodes.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root1 = [1], root2 = [1,2]\n<strong>Output:</strong> [2,2]\n<strong>Explanation:</strong> The merged tree combines both trees.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in both trees is in the range [0, 2000]</li>\n    <li>-10^4 ≤ Node.val ≤ 10^4</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 5,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {TreeNode}\n */\nvar mergeTrees = function(root1, root2) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,3,2,5]",
                    "[2,1,3,null,4,null,7]"
                ],
                "expectedOutput": "[3,4,5,5,4,null,7]",
                "explanation": "The merged tree is created by summing overlapping nodes."
            },
            {
                "inputs": [
                    "[1]",
                    "[1,2]"
                ],
                "expectedOutput": "[2,2]",
                "explanation": "The merged tree combines both trees."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,3,2,5]",
                    "[2,1,3,null,4,null,7]"
                ],
                "expectedOutput": "[3,4,5,5,4,null,7]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]",
                    "[1,2]"
                ],
                "expectedOutput": "[2,2]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]",
                    "[1,2,3]"
                ],
                "expectedOutput": "[1,2,3]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5]",
                    "[1,2,3,4,5]"
                ],
                "expectedOutput": "[2,4,6,8,10]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "TREE"
            ],
            "output": "TREE"
        }
    },
    {
        "_id": "8b9556b8-2179-4ed3-8dc1-6173b13154e8",
        "name": "Path Sum",
        "link": "path-sum/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.</p>\n\n  <p>A leaf is a node with no children.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The root-to-leaf path with the target sum is shown: 5 → 4 → 11 → 2 = 22</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3], targetSum = 5\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no root-to-leaf path with sum = 5.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [0, 5000]</li>\n    <li>-1000 ≤ Node.val ≤ 1000</li>\n    <li>-1000 ≤ targetSum ≤ 1000</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 6,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {number} targetSum\n * @return {boolean}\n */\nvar hasPathSum = function(root, targetSum) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[5,4,8,11,null,13,4,7,2,null,null,null,1]",
                    "22"
                ],
                "expectedOutput": "true",
                "explanation": "The root-to-leaf path with the target sum is shown: 5 → 4 → 11 → 2 = 22"
            },
            {
                "inputs": [
                    "[1,2,3]",
                    "5"
                ],
                "expectedOutput": "false",
                "explanation": "There is no root-to-leaf path with sum = 5."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[5,4,8,11,null,13,4,7,2,null,null,null,1]",
                    "22"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,3]",
                    "5"
                ],
                "expectedOutput": "false",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]",
                    "0"
                ],
                "expectedOutput": "false",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2]",
                    "1"
                ],
                "expectedOutput": "false",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER"
            ],
            "output": "BOOLEAN"
        }
    },
    {
        "_id": "9838c074-2da6-4dd2-a86e-1145ea897bfe",
        "name": "Construct String from Binary Tree",
        "link": "construct-string-from-binary-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it.</p>\n\n  <p>Omit all the empty parenthesis pairs that don't affect the one-to-one mapping relationship between the string and the original binary tree.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3,4]\n<strong>Output:</strong> \"1(2(4))(3)\"\n<strong>Explanation:</strong> Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\".</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3,null,4]\n<strong>Output:</strong> \"1(2()(4))(3)\"\n<strong>Explanation:</strong> Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 10^4]</li>\n    <li>-1000 ≤ Node.val ≤ 1000</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 7,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def tree2str(self, root: Optional[TreeNode]) -> str:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {string}\n */\nvar tree2str = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3,4]"
                ],
                "expectedOutput": "\"1(2(4))(3)\"",
                "explanation": "Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs."
            },
            {
                "inputs": [
                    "[1,2,3,null,4]"
                ],
                "expectedOutput": "\"1(2()(4))(3)\"",
                "explanation": "Almost the same as the first example, except we cannot omit the first parenthesis pair."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3,4]"
                ],
                "expectedOutput": "\"1(2(4))(3)\"",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,3,null,4]"
                ],
                "expectedOutput": "\"1(2()(4))(3)\"",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "\"1\"",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3]"
                ],
                "expectedOutput": "\"1(2)(3)\"",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "STRING"
        }
    },
    {
        "_id": "556eddd2-f62a-4338-84d9-227806e1b00e",
        "name": "Minimum Distance Between BST Nodes",
        "link": "minimum-distance-between-bst-nodes/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [4,2,6,1,3]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The minimum difference is 1, which is the difference between 2 and 1, or 3 and 2.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,0,48,null,null,12,49]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The minimum difference is 1, which is the difference between 1 and 0, or 48 and 49.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [2, 100]</li>\n    <li>0 ≤ Node.val ≤ 10^5</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 8,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def minDiffInBST(self, root: Optional[TreeNode]) -> int:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar minDiffInBST = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[4,2,6,1,3]"
                ],
                "expectedOutput": "1",
                "explanation": "The minimum difference is 1, which is the difference between 2 and 1, or 3 and 2."
            },
            {
                "inputs": [
                    "[1,0,48,null,null,12,49]"
                ],
                "expectedOutput": "1",
                "explanation": "The minimum difference is 1, which is the difference between 1 and 0, or 48 and 49."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[4,2,6,1,3]"
                ],
                "expectedOutput": "1",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,0,48,null,null,12,49]"
                ],
                "expectedOutput": "1",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,3,4,5]"
                ],
                "expectedOutput": "1",
                "isHidden": true
            },
            {
                "inputs": [
                    "[10,5,15,3,7,12,18]"
                ],
                "expectedOutput": "2",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "9f87b99b-139f-4da0-a4c5-7066c10636b4",
        "name": "Symmetric Tree",
        "link": "symmetric-tree/",
        "group": "Trees",
        "difficulty": "Easy",
        "description": "<div>\n  <p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,2,3,4,4,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> The tree is symmetric around its center.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,2,null,3,null,3]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The tree is not symmetric around its center.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 1000]</li>\n    <li>-100 ≤ Node.val ≤ 100</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 9,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isSymmetric(self, root: Optional[TreeNode]) -> bool:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isSymmetric = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,2,3,4,4,3]"
                ],
                "expectedOutput": "true",
                "explanation": "The tree is symmetric around its center."
            },
            {
                "inputs": [
                    "[1,2,2,null,3,null,3]"
                ],
                "expectedOutput": "false",
                "explanation": "The tree is not symmetric around its center."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,2,3,4,4,3]"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,2,null,3,null,3]"
                ],
                "expectedOutput": "false",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3]"
                ],
                "expectedOutput": "false",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "BOOLEAN"
        }
    },
    {
        "_id": "93da241e-70b9-4785-a144-63758bdaba62",
        "name": "Find Duplicate Subtrees",
        "link": "find-duplicate-subtrees/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given the root of a binary tree, return all duplicate subtrees.</p>\n\n  <p>For each kind of duplicate subtrees, you only need to return the root node of any one of them.</p>\n\n  <p>Two trees are duplicate if they have the same structure with the same node values.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3,4,null,2,4,null,null,4]\n<strong>Output:</strong> [[2,4],[4]]\n<strong>Explanation:</strong> The duplicate subtrees are [2,4] and [4].</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [2,1,1]\n<strong>Output:</strong> [[1]]\n<strong>Explanation:</strong> The duplicate subtree is [1].</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of the nodes in the tree will be in the range [1, 10^4]</li>\n    <li>-200 ≤ Node.val ≤ 200</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 10,
        "templates": {
            "python": "from typing import List, Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def findDuplicateSubtrees(self, root: Optional[TreeNode]) -> List[Optional[TreeNode]]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {TreeNode[]}\n */\nvar findDuplicateSubtrees = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3,4,null,2,4,null,null,4]"
                ],
                "expectedOutput": "[[2,4],[4]]",
                "explanation": "The duplicate subtrees are [2,4] and [4]."
            },
            {
                "inputs": [
                    "[2,1,1]"
                ],
                "expectedOutput": "[[1]]",
                "explanation": "The duplicate subtree is [1]."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3,4,null,2,4,null,null,4]"
                ],
                "expectedOutput": "[[2,4],[4]]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[2,1,1]"
                ],
                "expectedOutput": "[[1]]",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]"
                ],
                "expectedOutput": "[]",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,1,1,1,1,1,1]"
                ],
                "expectedOutput": "[[1],[1,1]]",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "ARRAY_OF_TREES"
        }
    },
    {
        "_id": "ccea0e93-f84d-4984-916b-5c2ce7733ce0",
        "name": "House Robber III",
        "link": "house-robber-iii/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root.</p>\n\n  <p>Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night.</p>\n\n  <p>Given the root of the binary tree, return the maximum amount of money the thief can rob tonight without alerting the police.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,2,3,null,3,null,1]\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [3,4,5,1,3,null,1]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Maximum amount of money the thief can rob = 4 + 5 = 9.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 10^4]</li>\n    <li>0 ≤ Node.val ≤ 10^4</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 11,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar rob = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,2,3,null,3,null,1]"
                ],
                "expectedOutput": "7",
                "explanation": "Maximum amount of money the thief can rob = 3 + 3 + 1 = 7."
            },
            {
                "inputs": [
                    "[3,4,5,1,3,null,1]"
                ],
                "expectedOutput": "9",
                "explanation": "Maximum amount of money the thief can rob = 4 + 5 = 9."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,2,3,null,3,null,1]"
                ],
                "expectedOutput": "7",
                "isHidden": false
            },
            {
                "inputs": [
                    "[3,4,5,1,3,null,1]"
                ],
                "expectedOutput": "9",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "1",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3]"
                ],
                "expectedOutput": "5",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "8b565bf1-70f3-4247-9047-57dead4c891a",
        "name": "Time Needed to Inform All Employees",
        "link": "time-needed-to-inform-all-employees/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>A company has n employees with a unique ID for each employee from 0 to n - 1. The head of the company is the one with headID.</p>\n\n  <p>Each employee has one direct manager given in the manager array where manager[i] is the direct manager of the i-th employee, manager[headID] = -1. Also, it is guaranteed that the subordination relationships have a tree structure.</p>\n\n  <p>The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.</p>\n\n  <p>The i-th employee needs informTime[i] minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).</p>\n\n  <p>Return the number of minutes needed to inform all the employees about the urgent news.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> n = 1, headID = 0, manager = [-1], informTime = [0]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The head of the company is the only employee in the company.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>1 ≤ n ≤ 10^5</li>\n    <li>0 ≤ headID < n</li>\n    <li>manager.length == n</li>\n    <li>0 ≤ manager[i] < n for all i != headID</li>\n    <li>manager[headID] == -1</li>\n    <li>informTime.length == n</li>\n    <li>0 ≤ informTime[i] ≤ 1000</li>\n    <li>informTime[i] == 0 if employee i has no subordinates</li>\n    <li>It is guaranteed that all employees can be informed</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 12,
        "templates": {
            "python": "from typing import List\n\nclass Solution:\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * @param {number} n\n * @param {number} headID\n * @param {number[]} manager\n * @param {number[]} informTime\n * @return {number}\n */\nvar numOfMinutes = function(n, headID, manager, informTime) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "1",
                    "0",
                    "[-1]",
                    "[0]"
                ],
                "expectedOutput": "0",
                "explanation": "The head of the company is the only employee in the company."
            },
            {
                "inputs": [
                    "6",
                    "2",
                    "[2,2,-1,2,2,2]",
                    "[0,0,1,0,0,0]"
                ],
                "expectedOutput": "1",
                "explanation": "The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "1",
                    "0",
                    "[-1]",
                    "[0]"
                ],
                "expectedOutput": "0",
                "isHidden": false
            },
            {
                "inputs": [
                    "6",
                    "2",
                    "[2,2,-1,2,2,2]",
                    "[0,0,1,0,0,0]"
                ],
                "expectedOutput": "1",
                "isHidden": false
            },
            {
                "inputs": [
                    "7",
                    "6",
                    "[1,2,3,4,5,6,-1]",
                    "[0,6,5,4,3,2,1]"
                ],
                "expectedOutput": "21",
                "isHidden": true
            },
            {
                "inputs": [
                    "15",
                    "0",
                    "[-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]",
                    "[1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]"
                ],
                "expectedOutput": "3",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "NUMBER",
                "NUMBER",
                "ARRAY",
                "ARRAY"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "68360395-d8fd-4f50-8090-c268d41dd4a8",
        "name": "Check Completeness of a Binary Tree",
        "link": "check-completeness-of-a-binary-tree/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given the root of a binary tree, determine if it is a complete binary tree.</p>\n\n  <p>In a complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2^h nodes inclusive at the last level h.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3,4,5,6]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2,3,4,5,null,7]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> The node with value 7 isn't as far left as possible.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 100]</li>\n    <li>1 ≤ Node.val ≤ 1000</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 13,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def isCompleteTree(self, root: Optional[TreeNode]) -> bool:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isCompleteTree = function(root) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3,4,5,6]"
                ],
                "expectedOutput": "true",
                "explanation": "Every level before the last is full, and all nodes in the last level are as far left as possible."
            },
            {
                "inputs": [
                    "[1,2,3,4,5,null,7]"
                ],
                "expectedOutput": "false",
                "explanation": "The node with value 7 isn't as far left as possible."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3,4,5,6]"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,3,4,5,null,7]"
                ],
                "expectedOutput": "false",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE"
            ],
            "output": "BOOLEAN"
        }
    },
    {
        "_id": "7068cf29-4c40-4f0f-b052-944d6c94f98c",
        "name": "Flip Equivalent Binary Trees",
        "link": "flip-equivalent-binary-trees/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.</p>\n\n  <p>A binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.</p>\n\n  <p>Given the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> We flipped at nodes with values 1, 3, and 5.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root1 = [], root2 = []\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Both trees are empty.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in each tree is in the range [0, 100]</li>\n    <li>Each tree will have unique node values in the range [0, 99]</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 14,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def flipEquiv(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root1\n * @param {TreeNode} root2\n * @return {boolean}\n */\nvar flipEquiv = function(root1, root2) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[1,2,3,4,5,6,null,null,null,7,8]",
                    "[1,3,2,null,6,4,5,null,null,null,null,8,7]"
                ],
                "expectedOutput": "true",
                "explanation": "We flipped at nodes with values 1, 3, and 5."
            },
            {
                "inputs": [
                    "[]",
                    "[]"
                ],
                "expectedOutput": "true",
                "explanation": "Both trees are empty."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[1,2,3,4,5,6,null,null,null,7,8]",
                    "[1,3,2,null,6,4,5,null,null,null,null,8,7]"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[]",
                    "[]"
                ],
                "expectedOutput": "true",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2,3]",
                    "[1,3,2]"
                ],
                "expectedOutput": "true",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3]",
                    "[1,2,4]"
                ],
                "expectedOutput": "false",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "TREE"
            ],
            "output": "BOOLEAN"
        }
    },
    {
        "_id": "43b290a2-5833-4176-985b-c018c73aac3e",
        "name": "Lowest Common Ancestor of a Binary Tree II",
        "link": "lowest-common-ancestor-of-a-binary-tree-ii/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given the root of a binary tree, return the lowest common ancestor (LCA) of two given nodes, p and q. If either node p or q does not exist in the tree, return null. All values of the nodes in the tree are unique.</p>\n\n  <p>According to the definition of LCA on Wikipedia: \"The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\"</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 10\n<strong>Output:</strong> null\n<strong>Explanation:</strong> Node 10 does not exist in the tree, so return null.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [1, 10^4]</li>\n    <li>-10^9 ≤ Node.val ≤ 10^9</li>\n    <li>All Node.val are unique</li>\n    <li>p != q</li>\n  </ul>\n</div>",
        "list": [
            "ALL",
            "TOP 150"
        ],
        "order": 100201000,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a binary tree node.\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: Optional[TreeNode], p: Optional[TreeNode], q: Optional[TreeNode]) -> Optional[TreeNode]:\n        # Write your solution here\n        pass",
            "javascript": "/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function(root, p, q) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "1"
                ],
                "expectedOutput": "3",
                "explanation": "The LCA of nodes 5 and 1 is 3."
            },
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "4"
                ],
                "expectedOutput": "5",
                "explanation": "The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "1"
                ],
                "expectedOutput": "3",
                "isHidden": false
            },
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "4"
                ],
                "expectedOutput": "5",
                "isHidden": false
            },
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "10"
                ],
                "expectedOutput": "null",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3]",
                    "2",
                    "3"
                ],
                "expectedOutput": "1",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER",
                "NUMBER"
            ],
            "output": "NUMBER"
        }
    },
    {
        "_id": "0368a623-31e3-443c-9228-9fd903980171",
        "name": "Lowest Common Ancestor of a Binary Tree III",
        "link": "lowest-common-ancestor-of-a-binary-tree-iii/",
        "group": "Trees",
        "difficulty": "Medium",
        "description": "<div>\n  <p>Given two nodes of a binary tree p and q, return their lowest common ancestor (LCA).</p>\n\n  <p>Each node contains a parent pointer which links to its parent. The definition of LCA is the same as the previous problem.</p>\n\n  <p><strong>Example 1:</strong></p>\n  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> The LCA of nodes 5 and 1 is 3.</pre>\n\n  <p><strong>Example 2:</strong></p>\n  <pre><strong>Input:</strong> root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself.</pre>\n\n  <p><strong>Example 3:</strong></p>\n  <pre><strong>Input:</strong> root = [1,2], p = 1, q = 2\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The LCA of nodes 1 and 2 is 1.</pre>\n\n  <p><strong>Constraints:</strong></p>\n  <ul>\n    <li>The number of nodes in the tree is in the range [2, 10^5]</li>\n    <li>-10^9 ≤ Node.val ≤ 10^9</li>\n    <li>All Node.val are unique</li>\n    <li>p != q</li>\n    <li>p and q exist in the tree</li>\n  </ul>\n</div>",
        "list": [
            "ALL"
        ],
        "order": 100201001,
        "templates": {
            "python": "from typing import Optional\n\n# Definition for a Node.\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.parent = None\n\nclass Solution:\n    def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':\n        # Write your solution here\n        pass",
            "javascript": "/**\n * // Definition for a Node.\n * function Node(val) {\n *    this.val = val;\n *    this.left = null;\n *    this.right = null;\n *    this.parent = null;\n * };\n */\n\n/**\n * @param {Node} p\n * @param {Node} q\n * @return {Node}\n */\nvar lowestCommonAncestor = function(p, q) {\n    // Write your solution here\n};"
        },
        "exampleTestCases": [
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "1"
                ],
                "expectedOutput": "3",
                "explanation": "The LCA of nodes 5 and 1 is 3."
            },
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "4"
                ],
                "expectedOutput": "5",
                "explanation": "The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself."
            }
        ],
        "testCases": [
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "1"
                ],
                "expectedOutput": "3",
                "isHidden": false
            },
            {
                "inputs": [
                    "[3,5,1,6,2,0,8,null,null,7,4]",
                    "5",
                    "4"
                ],
                "expectedOutput": "5",
                "isHidden": false
            },
            {
                "inputs": [
                    "[1,2]",
                    "1",
                    "2"
                ],
                "expectedOutput": "1",
                "isHidden": true
            },
            {
                "inputs": [
                    "[1,2,3,4,5,6,7]",
                    "4",
                    "5"
                ],
                "expectedOutput": "2",
                "isHidden": true
            }
        ],
        "types": {
            "inputs": [
                "TREE",
                "NUMBER",
                "NUMBER"
            ],
            "output": "NUMBER"
        }
    }
]